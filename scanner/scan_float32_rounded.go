// Code generated by gen/gen_scan_float_rounded.go; DO NOT EDIT.
package scanner

import (
	"context"
	"errors"
	"io"
)

const vectorFloat32Size = 4 * 8

func scanFloat32Rounded(ctx context.Context, reader io.Reader, bufSize int, min float32, max float32, collector CollectorFunc, options *Options) {
	var (
		chunk     = make([]byte, bufSize)
		offset    = 0
		seeker, _ = reader.(io.Seeker)
	)

	for {
		if ctx.Err() != nil {
			return
		}

		n, err := io.ReadFull(reader, chunk)
		if n < 0 {
			n = 0
		}
		if n >= 4 {
			// 保证处理的长度始终是对齐到 4 字节的
			processable := (n / 4) * 4
			scanFloat32Vectorized(chunk[:processable], min, max, offset, collector)
		}
		offset += n
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			if options != nil {
				// 如果未读完期望大小, 尝试对齐到下一页
				nextOffset, ok := options.alignNextPage(seeker, uint64(offset))
				if ok {
					offset = int(nextOffset)
					continue
				}
			}
			break
		}
	}
}
