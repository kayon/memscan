//go:build ignore

package main

import (
	"fmt"
	"os"
	"text/template"
)

const roundedTemplateStr = `// Code generated by gen/gen_scan_float_rounded.go; DO NOT EDIT.
package scanner

import (
	"context"
	"errors"
	"io"
)

const vector{{.Name}}Size = {{.Type.Size}} * {{.Type.Factor}}

func scan{{.Name}}Rounded(ctx context.Context, reader io.Reader, bufSize int, min {{.Type.Type}}, max {{.Type.Type}}, collector CollectorFunc, options *Options) {
	var (
		chunk     = make([]byte, bufSize)
		offset    = 0
		seeker, _ = reader.(io.Seeker)
	)

	for {
		if ctx.Err() != nil {
			return
		}

		n, err := io.ReadFull(reader, chunk)
		if n < 0 {
			n = 0
		}
		if n >= {{.Type.Size}} {
			// 保证处理的长度始终是对齐到 {{.Type.Size}} 字节的
			processable := (n / {{.Type.Size}}) * {{.Type.Size}}
			scan{{.Type.Name}}Vectorized(chunk[:processable], min, max, offset, collector)
		}
		offset += n
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			if options != nil {
				// 如果未读完期望大小, 尝试对齐到下一页
				nextOffset, ok := options.alignNextPage(seeker, uint64(offset))
				if ok {
					offset = int(nextOffset)
					continue
				}
			}
			break
		}
	}
}
`

type TypeConfig struct {
	Name   string
	Type   string
	Size   int
	Factor int
}

func main() {
	configs := []TypeConfig{
		{Name: "Float32", Type: "float32", Size: 4, Factor: 8},
		{Name: "Float64", Type: "float64", Size: 8, Factor: 8},
	}

	tmpl := template.Must(template.New("gen_rounded").Parse(roundedTemplateStr))

	for _, cfg := range configs {
		fileName := fmt.Sprintf("../scan_%s_rounded.go", cfg.Type)
		f, err := os.Create(fileName)
		if err != nil {
			panic(fmt.Sprintf("failed to create file %s: %v", fileName, err))
		}

		data := struct {
			Name string
			Type TypeConfig
		}{
			Name: cfg.Name,
			Type: cfg,
		}

		err = tmpl.Execute(f, data)
		if err != nil {
			panic(fmt.Sprintf("failed to execute template for %s: %v", cfg.Name, err))
		}

		f.Close()
		fmt.Printf("Generated %s (Step: %d bytes)\n", fileName, cfg.Size*cfg.Factor)
	}
}
