//go:build ignore

package main

import (
	"fmt"
	"os"
	"text/template"
)

const roundedTemplateStr = `// Code generated by gen/gen_scan_float_rounded.go; DO NOT EDIT.
package scanner

import (
	"context"
	"io"
)

const vector{{.Name}}Size = {{.Type.Size}} * {{.Type.Factor}}

func scan{{.Name}}Rounded(ctx context.Context, reader io.Reader, bufSize int, min {{.Type.Type}}, max {{.Type.Type}}, collector Collector) {
	var (
		chunk     = make([]byte, bufSize)
		offset    = 0
	)

	for {
		if ctx.Err() != nil {
			return
		}

		n, err := io.ReadFull(reader, chunk)
		if n < {{.Type.Size}} {
			break
		}

		// 保证处理的长度始终是对齐到 {{.Type.Size}} 的
		processable := (n / {{.Type.Size}}) * {{.Type.Size}}
		
		scan{{.Name}}Vectorized(chunk[:processable], min, max, offset, collector)
		offset += n

		if err != nil {
			// io.ErrUnexpectedEOF
			break
		}
	}
}
`

type TypeConfig struct {
	Name   string
	Type   string
	Size   int
	Factor int
}

func main() {
	configs := []TypeConfig{
		{Name: "Float32", Type: "float32", Size: 4, Factor: 8},
		{Name: "Float64", Type: "float64", Size: 8, Factor: 8},
	}

	tmpl := template.Must(template.New("gen_rounded").Parse(roundedTemplateStr))

	for _, cfg := range configs {
		fileName := fmt.Sprintf("../scan_%s_rounded.go", cfg.Type)
		f, err := os.Create(fileName)
		if err != nil {
			panic(fmt.Sprintf("failed to create file %s: %v", fileName, err))
		}

		data := struct {
			Name string
			Type TypeConfig
		}{
			Name: cfg.Name,
			Type: cfg,
		}

		err = tmpl.Execute(f, data)
		if err != nil {
			panic(fmt.Sprintf("failed to execute template for %s: %v", cfg.Name, err))
		}

		f.Close()
		fmt.Printf("Generated %s (Step: %d bytes)\n", fileName, cfg.Size*cfg.Factor)
	}
}
