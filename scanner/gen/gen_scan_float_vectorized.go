//go:build ignore

package main

import (
	"fmt"
	"os"
	"text/template"
)

const templateStr = `// Code generated by gen/gen_scan_float_vectorized.go; DO NOT EDIT.
package scanner

import "unsafe"

func scan{{.Name}}Vectorized(data []byte, min, max {{.Type.Type}}, offset int, collector Collector) {
	n := len(data)
	if n < {{.Type.Size}} {
		return
	}
	basePtr := uintptr(unsafe.Pointer(&data[0]))
	i := 0

	for ; i <= n-{{.Step}}; i += {{.Step}} {
		{{- range .Items}}
		v{{.Index}} := *(*{{$.Type.Type}})(unsafe.Pointer(basePtr + uintptr(i+{{.Offset}})))
		{{- end}}

		{{- range .Items}}
		if v{{.Index}} >= min && v{{.Index}} < max {
			collector.Collect(offset+i+{{.Offset}})
		}
		{{- end}}
	}

	for ; i <= n-{{.Type.Size}}; i += {{.Type.Size}} {
		val := *(*{{.Type.Type}})(unsafe.Pointer(basePtr + uintptr(i)))
		if val >= min && val < max {
			collector.Collect(offset+i)
		}
	}
	return
}
`

type TypeConfig struct {
	Name   string
	Type   string
	Size   int
	Factor int // 每个类型独立的展开因子
}

type UnrollItem struct {
	Index  int
	Offset int
}

func main() {
	configs := []TypeConfig{
		{Name: "Float32", Type: "float32", Size: 4, Factor: 8},
		{Name: "Float64", Type: "float64", Size: 8, Factor: 8},
	}

	tmpl := template.Must(template.New("gen").Parse(templateStr))

	for _, cfg := range configs {
		items := make([]UnrollItem, cfg.Factor)
		for i := 0; i < cfg.Factor; i++ {
			items[i] = UnrollItem{
				Index:  i,
				Offset: i * cfg.Size,
			}
		}

		fileName := fmt.Sprintf("../scan_%s_vectorized.go", cfg.Type)
		f, err := os.Create(fileName)
		if err != nil {
			panic(err)
		}

		data := struct {
			Name   string
			Type   TypeConfig
			Factor int
			Step   int
			Items  []UnrollItem
		}{
			Name:   cfg.Name,
			Type:   cfg,
			Factor: cfg.Factor,
			Step:   cfg.Factor * cfg.Size,
			Items:  items,
		}

		err = tmpl.Execute(f, data)
		f.Close()
		fmt.Printf("Generated %s (Factor: %d)\n", fileName, cfg.Factor)
	}
}
